from flask import Flask, request, render_template
from flask_cors import CORS, cross_origin


# -*- coding: utf-8 -*-
"""U_I_for_identification_of_black_spot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WVZxWRsiuBvigVxOMr0_Os8RTxD_ZTTV
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install geopandas
# %pip install matplotlib
import geopandas as gpd
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from pyproj import Geod
from shapely.geometry import Point, LineString
from shapely.ops import nearest_points
from shapely import geometry, ops
import os

geod = Geod(ellps="WGS84")

  # Commented out IPython magic to ensure Python compatibility.
  # %pip install openpyxl
  # Change the name of the file accordingly
def tester(ipfile):
  main_data = pd.read_excel(ipfile)

  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace")
  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/Shapefile_input")
  from zipfile import ZipFile
    
  # loading the temp.zip and creating a zip object
  with ZipFile("C:/Users/91817/Downloads/BTP Project/Shapefile.zip", 'r') as zObject:
    
      # Extracting all the members of the zip 
      # into a specific location.
      zObject.extractall(
          path="C:/Users/91817/Downloads/BTP Project/MyWorkspace/Shapefile_input")
  #!unzip /content/drive/MyDrive/Shapefile.zip -d "/MyWorkspace/Shapefile_input"

  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output")
  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output/National+State")
  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output/National")
  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output/State")

  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output/National+State/excel")
  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output/National/excel")
  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output/State/excel")

  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output/National+State/pickle")
  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output/National/pickle")
  os.mkdir("C:/Users/91817/Downloads/BTP Project/MyWorkspace/output/State/pickle")

  Storage_path = "C:/Users/91817/Downloads/BTP Project/MyWorkspace/output"

  # Boundaries of the state

  top_lat = 28
  left_lon = 85
  right_lon = 90
  bottom_lat = 21

  """#Data import

  ##Accident points data
  """

  df = []
  points = []
  points_hash = []
  #for ind in range(len(main_data)):
  for ind in range(100):
    temp = main_data.iloc[ind]
    if(type(temp['LONGITUDE'])==type(1.0) and type(temp['LATITUDE'])==type(1.0)):
      if(temp['LONGITUDE'] > left_lon and temp['LONGITUDE'] < right_lon and temp['LATITUDE'] > bottom_lat and temp['LATITUDE'] < top_lat):
        df.append(temp)
        points.append(Point(temp['LONGITUDE'],temp['LATITUDE']))
        points_hash.append(str(Point(temp['LONGITUDE'],temp['LATITUDE'])))

  """##Road Network data"""

  Input_shp = os.listdir('C:/Users/91817/Downloads/BTP Project/MyWorkspace/Shapefile_input')
  shp_files = list(filter(lambda f: f.endswith('.shp'),Input_shp))

  All_roads = []
  for i in range(len(shp_files)):
    All_roads.append(gpd.read_file('C:/Users/91817/Downloads/BTP Project/MyWorkspace/Shapefile_input/'+shp_files[i]))

  Roads_filtered = []
  for i in range(len(All_roads)):
    temp = All_roads[i]
    for j in range(len(temp)):
      if temp['ref'][j]!=None:
        Roads_filtered.append([temp['geometry'][j],temp['ref'][j]])

  """### fillings the gaps in the road network"""

  def merge(line):
    f1,e1 = line[0].boundary
    f2,e2 = line[1].boundary

    joint = LineString([e1,f2])

    merged_line = ops.linemerge([line[0],joint,line[1]])
    return merged_line

  lineString_type = type(LineString([Point(0, 0), Point(1, 1)]))  # to the type and compare to see if there are any MULTILINESTRING
  # we are merging as we need all the roads to be in the type of LINESTRING

  for i in range(len(Roads_filtered)):
    if type(Roads_filtered[i][0])!=lineString_type :
      Roads_filtered[i][0] = merge(Roads_filtered[i][0])

  # Roads_filtered[811][0]

  """#Methodology

  ##Segmenting road network
  """

  def cut(line, distance, lines):
      # Cuts a line in several segments at a distance from its starting pointz
      if distance <= 0.0 or distance >= line.length:
          return [LineString(line)]
      coords = list(line.coords)
      for i, p in enumerate(coords):
          pd = line.project(Point(p))
          if pd == distance:
              return [ LineString(coords[:i+1]), LineString(coords[i:]) ]
          if pd > distance:
              cp = line.interpolate(distance)
              lines.append(LineString(coords[:i] + [(cp.x, cp.y)]))
              line = LineString([(cp.x, cp.y)] + coords[i:])
              if line.length > distance:
                  cut(line, distance, lines)
              else:
                  lines.append(LineString([(cp.x, cp.y)] + coords[i:]))
              return lines

  roads_new = []   # network after segmenting according to required length
  distance_delta = 0.0048  # this 0.01 gives around 1024m of length for each segment
  id = 1

  for i in range(len(Roads_filtered)):
    line = Roads_filtered[i][0]
    
    result = cut(line, distance_delta, list())
    for k in result:
      if(Roads_filtered[i][1][0]=='N'):
        roads_new.append([k,Roads_filtered[i][1],id,"National Highway"])
      else:
        roads_new.append([k,Roads_filtered[i][1],id,"State Highway"])
      id+=1

  print(len(roads_new))

  roads_new = [x for x in roads_new if (geod.geometry_length(x[0])>400 and geod.geometry_length(x[0])<600) ]

  len(roads_new)

  length = 0
  for l in roads_new:
    length+=geod.geometry_length(l[0])
  length

  """##Assigning points to road segment"""

  def findDistance(p):
    min_dis = 10000000
    ind = 0
    for i in range(len(roads_new)):
      line = roads_new[i][0]
      distance = geod.geometry_length(LineString(nearest_points(line, p)))
      if min_dis > distance:
        ind = roads_new[i][2]
        min_dis = distance
    return ind,min_dis

  seg_dic = dict()
  for l in range(len(roads_new)):
    seg_dic[roads_new[l][2]] = {
      "id" : roads_new[l][2],
      "Highway_type" : roads_new[l][3],
      "Segment_geometry" : roads_new[l][0],
      "Highway_Name" : roads_new[l][1],
      "length" : geod.geometry_length(roads_new[l][0]),
      "tot_points" : 0,
      "points" : []
    }

  point_dic = dict()

  for i in range(len(points)):
    hash = str(points[i])
    point_dic[hash] = {
        "segment_id" : 999999,
        "Point_geometry" : points[i],
        "data" : df[i]
    }

  for i in range(len(points)):
    point = points[i]
    ind=0           #indicate the index of the linesegment in which it present
    ind,min_dis = findDistance(point)
    # print(i)
    if(min_dis<100):     #100 meters is the buffer distance
      seg_dic[ind]['points'].append(point)
      seg_dic[ind]['tot_points']+=1

      point_hash = str(point)
      point_dic[point_hash]['segment_id'] = ind    #here ind+1 is provided because we are starting index with 1

  segment_df = pd.DataFrame(seg_dic)
  segment_df = segment_df.T

  point_df = pd.DataFrame(point_dic)
  point_df = point_df.T

  # Storing it in two places to allow the ease of access in the rest of the process and download
  segment_df.to_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/segment_df.pkl')
  segment_df.to_pickle(Storage_path+'/segment_df.pkl')

  segment_df.to_excel('C:/Users/91817/Downloads/BTP Project/MyWorkspace/segment_df.xlsx')
  segment_df.to_excel(Storage_path+'/segment_df.xlsx')

  point_df.to_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/point_df.pkl')
  point_df.to_pickle(Storage_path+'/point_df.pkl')

  point_df.to_excel('C:/Users/91817/Downloads/BTP Project/MyWorkspace/point_df.xlsx')
  point_df.to_excel(Storage_path+'/point_df.xlsx')

  """#Creating duplicate excel with segment id"""

  point_df = pd.read_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/point_df.pkl')

  list_seg_id = [999999]*(len(df))

  for i in range(len(point_df)):
    list_seg_id[i] = (point_df['segment_id'][str(point_df['Point_geometry'][i])])

  dup = df
  dup = pd.DataFrame(dup,columns = main_data.columns)
  dup.insert(1,'segment_id',list_seg_id)
  dup.drop(dup.columns[[0]],axis = 1,inplace = True)

  dup.head()

  dup.to_excel('C:/Users/91817/Downloads/BTP Project/MyWorkspace/dup.xlsx')
  dup.to_excel(Storage_path+'/dup.xlsx')

  dup.to_pickle(Storage_path+'/dup.pkl')
  dup.to_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/dup.pkl')

  """# Dataframe preparation
  ##### Parameters used for ranking
  ##### 1. No. Fatal crash
  ##### 2. Fatal acc + Major injury
  ##### 3. Total crash frequency
  ##### 4. Crash density
  ##### 5. Equivalent Property damage
  """

  segment_df = pd.read_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/segment_df.pkl')
  point_df = pd.read_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/point_df.pkl')
  final_df = segment_df

  final_df = final_df.reset_index()

  fatal_crash_list = []
  fatal_major_list = []
  fatal_rate_list = []
  crash_density_list = []
  minor_injury_list = []
  no_injury_list = []
  fatal_people_list = []
  for i in range(len(segment_df)):
    temp = segment_df.iloc[i]
    plist = temp['points']
    fatal_crash = 0
    fatal_major = 0
    fatal_rate = 0
    crash_density = 0
    minor_injury = 0
    no_injury = 0
    fatal_people = 0
    for j in range(temp['tot_points']):
      hash_val = str(plist[j])
      if point_df['data'][hash_val]['ACCIDENT TYPE']=='Fatal':    #In this case the fatal crash means if the accident is fatal or not
        fatal_crash += 1
      if point_df['data'][hash_val]['ACCIDENT TYPE']=='Fatal' or 'Grievous Injured (Need Hospitalization)':
        fatal_major += 1
      if point_df['data'][hash_val]['ACCIDENT TYPE']=='Minor Injury (No Need of Hospitalization)':
        minor_injury += 1
      if point_df['data'][hash_val]['ACCIDENT TYPE']=='Non Injury':
        no_injury += 1

      fatal_people += point_df['data'][hash_val]['NO OF FATALITIES']
    

    if temp['tot_points']>0:
      fatal_rate = fatal_crash/temp['tot_points']
      crash_density = temp['tot_points']/temp['length']

    fatal_crash_list.append(fatal_crash)
    fatal_major_list.append(fatal_major)
    fatal_rate_list.append(fatal_rate)
    crash_density_list.append(crash_density)
    minor_injury_list.append(minor_injury)
    no_injury_list.append(no_injury)
    fatal_people_list.append(fatal_people)

  final_df['fatal_crash'] = fatal_crash_list
  final_df['fatal_major_crash'] = fatal_major_list
  final_df['fatal_rate'] = fatal_rate_list
  final_df['Crash_frequency'] = final_df['tot_points']
  final_df['crash_density'] = crash_density_list
  final_df['minor_injury'] = minor_injury_list
  final_df['no_injury'] = no_injury_list
  final_df['fatal_people'] = fatal_people_list

  final_df['EPDO'] = (final_df['fatal_major_crash']-final_df['fatal_crash'])*15+(final_df['fatal_crash'])*33+(final_df['minor_injury'])*1.16+(final_df['no_injury'])

  final_df[final_df['tot_points']>1]

  final_df.to_pickle(Storage_path+'/final_df.pkl')
  final_df.to_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/final_df.pkl')

  final_df.to_excel(Storage_path+'/final_df.xlsx')
  final_df.to_excel('C:/Users/91817/Downloads/BTP Project/MyWorkspace/final_df.xlsx')

  """# National and State Highway"""

  # Ranking = final_df
  Ranking = pd.read_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/final_df.pkl')

  # Removing the road segments which do not contain any accidents
  Ranking = Ranking[Ranking['tot_points']>0]

  #path of the folder for file to be saved
  path = Storage_path+'/National+State'

  """MORTH"""

  Ranking_morth = Ranking[(Ranking['fatal_people']>=10) | (Ranking['fatal_major_crash']>=5)]

  MORTH = Ranking_morth[['id','Segment_geometry']]
  MORTH.columns = ['id','SEG']

  #downloads
  MORTH.to_pickle(path+'/pickle'+'/MORTH.pkl')

  MORTH.to_excel(path+'/excel'+'/MORTH.xlsx')

  """Total Accidents"""

  mean = Ranking['tot_points'].mean()
  std = Ranking['tot_points'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_freq = Ranking[Ranking['tot_points']>=sig_level]

  TCF = Ranking_freq[['id','Segment_geometry']]

  #downloads
  TCF.to_pickle(path+'/pickle'+'/TCF.pkl')

  TCF.to_excel(path+'/excel'+'/TCF.xlsx')

  """Fatal Accidents"""

  mean = Ranking['fatal_crash'].mean()
  std = Ranking['fatal_crash'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_fatal = Ranking[Ranking['tot_points']>=sig_level]

  FCF = Ranking_freq[['id','Segment_geometry']]

  #downloads
  FCF.to_pickle(path+'/pickle'+'/FCF.pkl')

  FCF.to_excel(path+'/excel'+'/FCF.xlsx')

  """Fatal and Major Accidents"""

  mean = Ranking['fatal_major_crash'].mean()
  std = Ranking['fatal_major_crash'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_fatal_major = Ranking[Ranking['fatal_major_crash']>=sig_level]

  FMCF = Ranking_fatal_major[['id','Segment_geometry']]

  #downloads
  FMCF.to_pickle(path+'/pickle'+'/FMCF.pkl')

  FMCF.to_excel(path+'/excel'+'/FMCF.xlsx')

  """Total Fatalities"""

  mean = Ranking['fatal_people'].mean()
  std = Ranking['fatal_people'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_fatalities = Ranking[Ranking['fatal_people']>=sig_level]

  FF = Ranking_fatalities[['id','Segment_geometry']]

  #downloads
  FF.to_pickle(path+'/pickle'+'/FF.pkl')

  FF.to_excel(path+'/excel'+'/FF.xlsx')

  """EPDO"""

  mean = Ranking['EPDO'].mean()
  std = Ranking['EPDO'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_EPDO = Ranking[Ranking['EPDO']>=sig_level]

  EPDO = Ranking_EPDO[['id','Segment_geometry']]

  #downloads
  EPDO.to_pickle(path+'/pickle'+'/EPDO.pkl')

  EPDO.to_excel(path+'/excel'+'/EPDO.xlsx')

  """Combined"""

  BS_list_1 = pd.merge(FCF,FF,how = 'outer',on = ['id'])
  BS_list_2 = pd.merge(FMCF,TCF,how = 'outer',on = ['id'])
  BS_list_3 = pd.merge(MORTH,EPDO,how = 'outer',on = ['id'])
  BS_list_4 = pd.merge(BS_list_1,BS_list_2,how = 'outer',on = ['id'])
  BS_list = pd.merge(BS_list_4,BS_list_3,how = 'outer',on = ['id'])

  BS_list_id = [BS_list['id']][0]
  BS_list_id = [int(x) for x in BS_list_id]

  final_list = []
  for i in range(len(BS_list)):
    id = BS_list_id[i]
    FCF_check = int(id in FCF['id'].values)
    FMCF_check = int(id in FMCF['id'].values)
    TCF_check = int(id in TCF['id'].values)
    FF_check = int(id in FF['id'].values)
    EPDO_check = int(id in EPDO['id'].values)
    MORTH_check = int(id in MORTH['id'].values)
    ind = final_df[final_df['id']==id].index
    ind = ind[0]
    final_list.append([id,final_df.iloc[ind,2],FCF_check,FMCF_check,TCF_check,FF_check,EPDO_check,MORTH_check])

  final_list = pd.DataFrame(final_list,columns = ['SEG_ID','SEG','FCF','FMCF','TCF','FF','EPDO','MORTH'])

  final_list['common'] = final_list['FCF']+final_list['FMCF']+final_list['TCF']+final_list['FF']+final_list['EPDO']+final_list['MORTH']

  #downloads
  final_list.to_pickle(path+'/pickle'+'/final_list.pkl')

  final_list.to_excel(path+'/excel'+'/final_list.xlsx')

  final_list.head()

  """# National Highway

  """

  # Ranking = final_df
  Ranking = pd.read_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/final_df.pkl')

  # Removing the road segments which do not contain any accidents
  Ranking = Ranking[Ranking['tot_points']>0] 

  Ranking = Ranking[Ranking['Highway_type']=="National Highway"]

  #path of the folder for file to be saved
  path = Storage_path+'/National'

  """MORTH"""

  Ranking_morth = Ranking[(Ranking['fatal_people']>=10) | (Ranking['fatal_major_crash']>=5)]

  MORTH = Ranking_morth[['id','Segment_geometry']]
  MORTH.columns = ['id','SEG']

  #downloads
  MORTH.to_pickle(path+'/pickle'+'/MORTH.pkl')

  MORTH.to_excel(path+'/excel'+'/MORTH.xlsx')

  """Total Accidents"""

  mean = Ranking['tot_points'].mean()
  std = Ranking['tot_points'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_freq = Ranking[Ranking['tot_points']>=sig_level]

  TCF = Ranking_freq[['id','Segment_geometry']]

  #downloads
  TCF.to_pickle(path+'/pickle'+'/TCF.pkl')

  TCF.to_excel(path+'/excel'+'/TCF.xlsx')

  """Fatal Accidents"""

  mean = Ranking['fatal_crash'].mean()
  std = Ranking['fatal_crash'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_fatal = Ranking[Ranking['tot_points']>=sig_level]

  FCF = Ranking_freq[['id','Segment_geometry']]

  #downloads
  FCF.to_pickle(path+'/pickle'+'/FCF.pkl')

  FCF.to_excel(path+'/excel'+'/FCF.xlsx')

  """Fatal and Major Accidents"""

  mean = Ranking['fatal_major_crash'].mean()
  std = Ranking['fatal_major_crash'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_fatal_major = Ranking[Ranking['fatal_major_crash']>=sig_level]

  FMCF = Ranking_fatal_major[['id','Segment_geometry']]

  #downloads
  FMCF.to_pickle(path+'/pickle'+'/FMCF.pkl')

  FMCF.to_excel(path+'/excel'+'/FMCF.xlsx')

  """Total Fatalities"""

  mean = Ranking['fatal_people'].mean()
  std = Ranking['fatal_people'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_fatalities = Ranking[Ranking['fatal_people']>=sig_level]

  FF = Ranking_fatalities[['id','Segment_geometry']]

  #downloads
  FF.to_pickle(path+'/pickle'+'/FF.pkl')

  FF.to_excel(path+'/excel'+'/FF.xlsx')

  """EPDO"""

  mean = Ranking['EPDO'].mean()
  std = Ranking['EPDO'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_EPDO = Ranking[Ranking['EPDO']>=sig_level]

  EPDO = Ranking_EPDO[['id','Segment_geometry']]

  #downloads
  EPDO.to_pickle(path+'/pickle'+'/EPDO.pkl')

  EPDO.to_excel(path+'/excel'+'/EPDO.xlsx')

  """Combined"""

  BS_list_1 = pd.merge(FCF,FF,how = 'outer',on = ['id'])
  BS_list_2 = pd.merge(FMCF,TCF,how = 'outer',on = ['id'])
  BS_list_3 = pd.merge(MORTH,EPDO,how = 'outer',on = ['id'])
  BS_list_4 = pd.merge(BS_list_1,BS_list_2,how = 'outer',on = ['id'])
  BS_list = pd.merge(BS_list_4,BS_list_3,how = 'outer',on = ['id'])

  BS_list_id = [BS_list['id']][0]
  BS_list_id = [int(x) for x in BS_list_id]

  final_list = []
  for i in range(len(BS_list)):
    id = BS_list_id[i]
    FCF_check = int(id in FCF['id'].values)
    FMCF_check = int(id in FMCF['id'].values)
    TCF_check = int(id in TCF['id'].values)
    FF_check = int(id in FF['id'].values)
    EPDO_check = int(id in EPDO['id'].values)
    MORTH_check = int(id in MORTH['id'].values)
    ind = final_df[final_df['id']==id].index
    ind = ind[0]
    final_list.append([id,final_df.iloc[ind,2],FCF_check,FMCF_check,TCF_check,FF_check,EPDO_check,MORTH_check])

  final_list

  final_list = pd.DataFrame(final_list,columns = ['SEG_ID','SEG','FCF','FMCF','TCF','FF','EPDO','MORTH'])

  final_list['common'] = final_list['FCF']+final_list['FMCF']+final_list['TCF']+final_list['FF']+final_list['EPDO']+final_list['MORTH']

  #downloads
  final_list.to_pickle(path+'/pickle'+'/final_list.pkl')

  final_list.to_excel(path+'/excel'+'/final_list.xlsx')

  final_list

  """# State Highway

  """

  # Ranking = final_df
  Ranking = pd.read_pickle('C:/Users/91817/Downloads/BTP Project/MyWorkspace/final_df.pkl')

  # Removing the road segments which do not contain any accidents
  Ranking = Ranking[Ranking['tot_points']>0] 

  Ranking = Ranking[Ranking['Highway_type']=="State Highway"]

  #path of the folder for file to be saved
  path = Storage_path+'/State'

  """MORTH"""

  Ranking_morth = Ranking[(Ranking['fatal_people']>=10) | (Ranking['fatal_major_crash']>=5)]

  MORTH = Ranking_morth[['id','Segment_geometry']]
  MORTH.columns = ['id','SEG']

  #downloads
  MORTH.to_pickle(path+'/pickle'+'/MORTH.pkl')

  MORTH.to_excel(path+'/excel'+'/MORTH.xlsx')

  """Total Accidents"""

  mean = Ranking['tot_points'].mean()
  std = Ranking['tot_points'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_freq = Ranking[Ranking['tot_points']>=sig_level]

  TCF = Ranking_freq[['id','Segment_geometry']]

  #downloads
  TCF.to_pickle(path+'/pickle'+'/TCF.pkl')

  TCF.to_excel(path+'/excel'+'/TCF.xlsx')

  """Fatal Accidents"""

  mean = Ranking['fatal_crash'].mean()
  std = Ranking['fatal_crash'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_fatal = Ranking[Ranking['tot_points']>=sig_level]

  FCF = Ranking_freq[['id','Segment_geometry']]

  #downloads
  FCF.to_pickle(path+'/pickle'+'/FCF.pkl')

  FCF.to_excel(path+'/excel'+'/FCF.xlsx')

  """Fatal and Major Accidents"""

  mean = Ranking['fatal_major_crash'].mean()
  std = Ranking['fatal_major_crash'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_fatal_major = Ranking[Ranking['fatal_major_crash']>=sig_level]

  FMCF = Ranking_fatal_major[['id','Segment_geometry']]

  #downloads
  FMCF.to_pickle(path+'/pickle'+'/FMCF.pkl')

  FMCF.to_excel(path+'/excel'+'/FMCF.xlsx')

  """Total Fatalities"""

  mean = Ranking['fatal_people'].mean()
  std = Ranking['fatal_people'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_fatalities = Ranking[Ranking['fatal_people']>=sig_level]

  FF = Ranking_fatalities[['id','Segment_geometry']]

  #downloads
  FF.to_pickle(path+'/pickle'+'/FF.pkl')

  FF.to_excel(path+'/excel'+'/FF.xlsx')

  """EPDO"""

  mean = Ranking['EPDO'].mean()
  std = Ranking['EPDO'].std()

  sig_level = mean+ 1.645*std        # 5% significant level is considered
  Ranking_EPDO = Ranking[Ranking['EPDO']>=sig_level]

  EPDO = Ranking_EPDO[['id','Segment_geometry']]

  #downloads
  EPDO.to_pickle(path+'/pickle'+'/EPDO.pkl')

  EPDO.to_excel(path+'/excel'+'/EPDO.xlsx')

  """Combined"""

  BS_list_1 = pd.merge(FCF,FF,how = 'outer',on = ['id'])
  BS_list_2 = pd.merge(FMCF,TCF,how = 'outer',on = ['id'])
  BS_list_3 = pd.merge(MORTH,EPDO,how = 'outer',on = ['id'])
  BS_list_4 = pd.merge(BS_list_1,BS_list_2,how = 'outer',on = ['id'])
  BS_list = pd.merge(BS_list_4,BS_list_3,how = 'outer',on = ['id'])

  BS_list_id = [BS_list['id']][0]
  BS_list_id = [int(x) for x in BS_list_id]

  final_list = []
  for i in range(len(BS_list)):
    id = BS_list_id[i]
    FCF_check = int(id in FCF['id'].values)
    FMCF_check = int(id in FMCF['id'].values)
    TCF_check = int(id in TCF['id'].values)
    FF_check = int(id in FF['id'].values)
    EPDO_check = int(id in EPDO['id'].values)
    MORTH_check = int(id in MORTH['id'].values)
    ind = final_df[final_df['id']==id].index
    ind = ind[0]
    final_list.append([id,final_df.iloc[ind,2],FCF_check,FMCF_check,TCF_check,FF_check,EPDO_check,MORTH_check])

  final_list = pd.DataFrame(final_list,columns = ['SEG_ID','SEG','FCF','FMCF','TCF','FF','EPDO','MORTH'])

  final_list['common'] = final_list['FCF']+final_list['FMCF']+final_list['TCF']+final_list['FF']+final_list['EPDO']+final_list['MORTH']

  #downloads
  final_list.to_pickle(path+'/pickle'+'/final_list.pkl')

  final_list.to_excel(path+'/excel'+'/final_list.xlsx')

  final_list.head()






app = Flask(__name__)
CORS(app)

@app.route('/', methods=['GET', 'POST'])
@cross_origin()
def homePage():
    try:
        return render_template('index.html')
    except Exception as e:
        return print(e)


@app.route('/prediction', methods=['POST'])
@cross_origin()
def index():
    try:
        if request.method == 'POST':
            
            datafile= request.form['excel']
            # tester(datafile)


            return render_template("results.html")
        else:
            return render_template("index.html")
    except Exception as e:
        return print(f"Error : {e}")


if __name__ == '__main__':
    app.run(debug=True, host="127.0.0.1", port=8001)